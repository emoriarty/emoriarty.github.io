{"data":{"config":{"html":"<p>El blog personal de Enrique Arias.\n<br />\n<span style=\"font-size: 0.9em; color: gray;\">Desarrollador y escritor ocasional entre otras cosas.</span></p>","fields":{"slug":"/es/"},"frontmatter":{"title":"Apuntes nocturnos","language":"es"}},"markdownRemark":{"id":"47e6c488-a9e3-5d8a-860f-5f07deede069","excerpt":"First-class function  es la cualidad por la que un lenguaje de programación puede tratar las funciones como si fueran cualquier otro tipo de…","html":"<p><em>First-class function</em> es la cualidad por la que un lenguaje de programación puede tratar las funciones como si fueran cualquier otro tipo de objeto. Se entiende por objeto cualquier tipo de entidad que pueda asignarse a una variable, almacenarse en un <em>array</em>, transferir como argumento e incluso ser devuelto como resultado de otra función.</p>\n<p>La idea en si proviene de otro concepto llamado <em><a href=\"https://en.wikipedia.org/wiki/First-class_citizen\">first-class citizen</a></em>. Este viene a decir que una entidad pueda soportar cualquier tipo de operación común disponible en otras entidades.</p>\n<p>En el ejemplo siguiente se muestra una función anónimo siendo asignada a una variable llamada {% ihighlight javascript %}sayHello{% endihighlight %}. El código mostrado es <em>Javascript</em> pero lo mismo aplica para otros lenguajes que soporten esta característica.</p>\n<p>{% highlight javascript %}\nconst sayHello = () => “Hello”;\n{% endhighlight %}</p>\n<p>Si exponemos la variable podremos ver que el contenido es la función previamente definida.</p>\n<p>{% highlight javascript %}\nsayHello; // () => “Hello”\n{% endhighlight %}</p>\n<p>Al añadir los dos paréntesis al final de la variable se ejecuta la función, devolviendo el resultado que acompaña a la cláusula {% ihighlight javascript %}return{% endihighlight %}. En el ejemplo se ha usado una función <em><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Funciones/Arrow_functions\">arrow</a></em>, introducida en la versión <em><a href=\"http://es6-features.org\">ES6</a></em> de <em><a href=\"https://es.wikipedia.org/wiki/ECMAScript\">ECMAScript</a></em>. Entre las propiedades de esta nueva especificación permite devolver el resultado sin necesidad de incluir el comando {% ihighlight javascript %}return{% endihighlight %}, tampoco el uso de llaves, cuando la función está contenida en una sola línea.</p>\n<p>{% highlight javascript %}\nsayHello(); // “Hello”\n{% endhighlight %}</p>\n<p>Puesto que es una variable, también podemos utilizarla como argumento en otras funciones.</p>\n<p>{% highlight javascript %}\nconst sayHelloWorld = (fn)  =>  fn() + ” World”;\nconst sayHelloElia = (fn) => fn() + ” Elia”;</p>\n<p>sayHelloWorld(sayHello); // “Hello World”\nsayHelloElia(sayHello); // “Hello Elia”\n{% endhighlight %}</p>\n<p>Obviamente el ejemplo anterior está diseñado solamente para mostrar la transferencia de funciones como argumentos. Lo óptimo hubiese sido que {% ihighlight javascript %}sayHello{% endihighlight %} aceptase un parámetro y concatenase su valor con el cuerpo del resultado.</p>\n<p>Otro ejemplo donde también se hace uso de esta característica son los habituales <em>callbacks</em> en <em>Javascript</em>. Estos no dejan de ser funciones anónimas (en la mayoría de los casos) que se utilizan como argumentos. Este encadenamiento de funciones puede llevar a crear capas de abstracción innecesarias.</p>\n<p>Seguro que alguna vez te has encontrado algo parecido al siguiente fragmento de código. Siempre son otros los que hacen las cosas mal.</p>\n<p>{% highlight javascript %}\najax.get(“/user/1”, function (data) {\nreturn showData(data);\n});\n{% endhighlight %}</p>\n<p>En la supuesta llamada a un <em>API</em> se describe una función anónima que puede recibir dos argumentos. El primero con los datos esperados y el segundo con el error. Pero en la función contenedora solo contiene un argumento. ¿Qué ocurriría si se produjese un error? Entonces debería modificarse todas las llamadas similares para aceptar este segundo argumento y suministrarlo a la función contenida {% ihighlight javascript %}showData{% endihighlight %}.</p>\n<p>{% highlight javascript %}\najax.get(“/user/1”, function (data, error) {\nreturn showData(data, error);\n});\n{% endhighlight %}</p>\n<p>Como veis es tontería. Hemos añadido una función que contiene a otra función que recibe el mismo número de argumentos. Por lo tanto, debemos eliminar este tipo de funciones <em>proxy</em> que solo añaden complejidad al código además de retrasar la evaluación del mismo. El resultado correcto sería el siguiente.</p>\n<p>{% highlight javascript %}\najax.get(“/user/1”, showData);\n{% endhighlight %}</p>\n<p>Y así queda mucho más legible, sucinto y elegante.</p>\n<p>Otro caso interesante es asignar funciones de distintos objetos en entidades propias de la aplicación. En el ejemplo siguiente puede verse como se crea una entidad {% ihighlight javascript %}User{% endihighlight %} que asigna por cada propiedad funciones pertenecientes a otros objetos. Esta característica permite crear entidades lógicas de manera fácil y menos verbosa. Al mismo tiempo se reutilizan funciones comunes reduciendo así los puntos donde podría provocarse un error.</p>\n<p>{% highlight javascript %}\nconst User = {\nfetch: api.getUser,\ncreate: api.createUser,\ndestroy: api.destroyUser,\nshow: view.show\n};\n{% endhighlight %}</p>\n<p><em>Et voilà!</em> Con esto deberías haberte hecho una idea de que es una <em>First-class function</em>.</p>\n<p>Entre los lenguajes que lo soportan a parte del mencionado <em>Javascript</em> estarían: <em>Haskell</em>, <em>Python</em>, <em>Scala</em>, <em>Perl</em>. En lenguajes imperativos como <em>C</em> y <em>Java</em> esta característica está soportada parcialmente.</p>\n<p>Otro asunto que aun no he mencionado y es por el que me he decidido a hacer este artículo (y otros que vendrán), es que la noción de que las funciones puedan ser tratadas como cualquier otro tipo de dato es la base de la programación funcional. Sin este recurso difícilmente podrían darse técnicas como <em>partial-application/currying</em> o <em>closures</em>, fundamentales para la composición de funciones. Un ejemplo podría ser el siguiente <em>snippet</em>.</p>\n<p>{% highlight javascript %}\nconst sayHello = (name) => “Hello ” + name;\nconst sayWorld = () => “World”;\nconst sayElia = () => “Elia”;</p>\n<p>const sayHelloWorld = compose(sayHello, sayWorld);\nconst sayHelloElia = compose(sayHello, sayElia);</p>\n<p>sayHelloWorld(); // “Hello World”\nsayHelloElia(); // “Hello Elia”\n{% endhighlight %}</p>\n<p>{% ihighlight javascript %}compose{% endihighlight %} es un tipo especial de función que puede conseguirse a través de librerías como <em><a href=\"http://ramdajs.com/docs/#compose\">Ramda</a></em> o <em><a href=\"https://lodash.com/docs/4.17.4#flowRight\">Lodash</a></em>. El propósito de esta función es generar nuevas funciones más complejas a partir de otras más sencillas que cumplen un único cometido (principio de responsabilidad única o <em>SRP</em>). Pero esto es otro concepto que veremos en un futuro.</p>\n<p>Como puedes apreciar hemos generado dos funciones a partir de otras tres. De no ser por la propiedad <em>First-class function</em> (entre otras cosas como <em>High order function</em>) este tipo de código no sería posible.</p>\n<p>¡Y esto es todo por ahora! Más adelante iré compartiendo otros artículos sobre terminología en programación.</p>\n<h2>Fuentes</h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/First-class_function\">en.wikipedia.org/wiki/First-class_function</a></li>\n<li><a href=\"https://stackoverflow.com/questions/10141124/any-difference-between-first-class-function-and-high-order-function\">stackoverflow.com/questions/10141124/any-difference-between-first-class-function-and-high-order-function</a>\n*<a href=\"http://www.i-programmer.info/programming/theory/5933-what-exactly-is-a-first-class-function-and-why-you-should-care.html\">i-programmer.info/programming/theory/5933-what-exactly-is-a-first-class-function-and-why-you-should-care.html</a></li>\n<li><a href=\"https://appendto.com/2016/10/javascript-functions-as-first-class-objects/\">appendto.com/2016/10/javascript-functions-as-first-class-objects/</a></li>\n<li><a href=\"https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch2.html\">drboolean.gitbooks.io/mostly-adequate-guide/content/ch2.html</a></li>\n</ul>","frontmatter":{"title":"First class function","date":"January 30, 2018","translations":null},"fields":{"readingTime":{"text":"5 min read","minutes":4.765}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/es/2018-01-30-first-class-funtion/","language":"es","previous":{"fields":{"slug":"/es/2018-01-26-vim-ctags/"},"frontmatter":{"title":"vim: ctags"}},"next":{"fields":{"slug":"/es/2018-03-20-pure-function/"},"frontmatter":{"title":"Pure Function"}}}}