{"data":{"config":{"html":"<p>Enrique Arias’ personal blog.\n<br />\n<span style=\"font-size: 0.9em; color: gray;\">Developer and occasional writer among other things.</span></p>","fields":{"slug":"/"},"frontmatter":{"title":"Nocturnal Notes","language":"en"}},"markdownRemark":{"id":"2bf3b2a6-75d9-5b43-8e3d-b92865be7835","excerpt":"Everyone who has spent some time working with git irremediably knows about \nmerging. Suppose we have a branch called A coming from master…","html":"<p>Everyone who has spent some time working with git irremediably knows about\nmerging. Suppose we have a branch called A coming from master. The merge\ncommand brings the changes carried in A into master.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">71a621b <span class=\"token punctuation\">(</span>HEAD -<span class=\"token operator\">></span> master<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span> A <span class=\"token function\">file</span> updated\n2dc6065 <span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span> new A <span class=\"token function\">file</span>\n76a1097 Demo <span class=\"token function\">file</span> updated\na31e004 README updated\n44d4c5b New README <span class=\"token function\">file</span>\nee42779 New demo <span class=\"token function\">file</span></code></pre></div>\n<p>It does works fine, changes are placed ahead in the master branch.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">1———2———3———A1———A2</code></pre></div>\n<p>The log reflects an incremental order of commits, or put in other words,\nthe commits are shown in the same order were added. A timeline of changes.</p>\n<p>When these modifications have happened at the same time in a B branch, which\nis not as rarely as it seems, the merge strategy cannot do a fast-forward\nupdate (bring changes ahead).</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">057a856 <span class=\"token punctuation\">(</span>HEAD -<span class=\"token operator\">></span> master<span class=\"token punctuation\">)</span> Merge branch <span class=\"token string\">'B'</span>\n71a621b <span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span> A <span class=\"token function\">file</span> updated\n1ac6aff <span class=\"token punctuation\">(</span>B<span class=\"token punctuation\">)</span> B <span class=\"token function\">file</span> updated\n2dc6065 <span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span> new A <span class=\"token function\">file</span>\nd657116 <span class=\"token punctuation\">(</span>B<span class=\"token punctuation\">)</span> new B <span class=\"token function\">file</span>\n76a1097 Demo <span class=\"token function\">file</span> updated\na31e004 README updated\n44d4c5b New README <span class=\"token function\">file</span>\nee42779 New demo <span class=\"token function\">file</span></code></pre></div>\n<p>Because changes did happened in the same time frame, the merge command makes\nuse of a recursive strategy interlacing A and B commits.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">1———2———3———B1———A1———B2———A2</code></pre></div>\n<p>Interlaced commits don’t keep proper track of branching blocks. There is a way\nto prevent this scenario once a feature is completed. Instead of merging the\nwhole bunch of commits, a better option is pushing the changes into master (or\ndevelop) as a unique commit with a descriptive message. This approach improves\nreadability and traceability of the git log.</p>\n<p>Perhaps for personal or one-man sized projects is not too important (it is better\nto keep at good habits, though) having a strict sorted timeline of events. But\nwhen comes to big teams where each feature needs to be perfectly isolated and\ntagged an unsorted log history would make the difference between mayhem and\nharmony.</p>\n<p>For those newbies in git (and whose did not find much time to dive into)\nthere’s more than only merging. Let’s go beyond merge.</p>\n<h2>Rebase</h2>\n<p>Unlike merge, rebase allows to do the merge based on a feature branch keeping\ntrack of those related commits blocks in the same slot.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">1———2———3———A1———A2———B1———A2</code></pre></div>\n<p>While the origin branch’s history\nkeeps linear, the new feature commits are placed just ahead, maintaining a\nmore coherent log.</p>\n<p>A convenient way to prevent conflicts while working on a feature branch is to\nbring frequently the latest changes from origin branch.</p>\n<div class=\"gatsby-highlight\" data-language=\"git\"><pre class=\"language-git\"><code class=\"language-git\">> git rebase &lt;origin-branch> </code></pre></div>\n<p>Having a the next branching state.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">        B1———B2\n       /\nA1———A2———A3———A4</code></pre></div>\n<p><code class=\"language-text\">rebase</code> permits removing momentarily the current commits (the ones that are not\npresent in the origin branch), put in place the new changes and install on top\nfeature commits again.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">                  B1———B2\n                 /\nA1———A2———A3———A4</code></pre></div>\n<p>While updating the branch is intended to be carried out as often as possible,\nsometimes the differences between both branches are too complex that conflicts\narise. As with merge conflicts must be resolved but interactevely. <code class=\"language-text\">rebase</code> let\nus decide what to do in case of conflicts: fix them and continue or abort. Below\nthere’s a list with the most used options.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> rebase --continue <span class=\"token comment\"># follow rebase</span>\n<span class=\"token function\">git</span> rebase --skip     <span class=\"token comment\"># jump current conflict</span>\n<span class=\"token function\">git</span> rebase —-abort    <span class=\"token comment\"># stop rebase and leave things as thet were</span>\n<span class=\"token function\">git</span> rebase --quit     <span class=\"token comment\"># like abort but keeping the committed changes</span></code></pre></div>\n<h2>Forcing push for rebased branches</h2>\n<p>It can happen when rebasing, sometimes, the remote repository rejects new\nchanges because of the rebase itself. The rejection message will read something\nabout our local branch is behind the remote one.</p>\n<p>When the rebase is executed, the new changes are put in the middle of the\ncommits stack, desynchronising with the remote picture. In this particular\ncase, the message is confusing, it will ask you to updated from remote branch\nwhich, obviously, we don’t want.</p>\n<p>In order to solve this problem, the push command can be forced by passing the\n<code class=\"language-text\">--force</code> option.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> push --force</code></pre></div>\n<p>Never, ever, force a push on a collaborative branch. It will destroy\nmodifications being carried out by other repository members and you will\nbecome a hatred object among colleagues. Use <code class=\"language-text\">--force</code> only with your own\nbranches.</p>\n<p>To prevent possible overwritings on the remote branch, there is the\n<code class=\"language-text\">--force-with-lease</code> option. Whilst the <code class=\"language-text\">--force</code> option will push changes no\nmatter what, <code class=\"language-text\">--force-with-lease</code> won’t allow any update if some other\ncollaborator has added changes to the remote branch. So, remember, always is\npreferable using this option.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> push --force-with-lease</code></pre></div>\n<h2>Choosing commits</h2>\n<p>While working in a branch we don’t pay much attention how the the commit\nhistory looks like. In fact we are focused on development. But when the current\nwork is already completed, is time to sort the log. We don’t want to look like\nwe’re suffering Diogenes syndrome, accumulating all those non-useful commits.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">259aff2 <span class=\"token punctuation\">(</span>HEAD -<span class=\"token operator\">></span> A<span class=\"token punctuation\">)</span> body edit\n7a48555 wip: body content\n71a621b A <span class=\"token function\">file</span> updated\n2dc6065 new A <span class=\"token function\">file</span>\nd9ad32e <span class=\"token punctuation\">(</span>master<span class=\"token punctuation\">)</span> A new commit is introduced <span class=\"token keyword\">while</span> previous changes are <span class=\"token keyword\">in</span> stash\n13b16a5 Revert <span class=\"token string\">\"README updated\"</span>\n76a1097 Demo <span class=\"token function\">file</span> updated\na31e004 README updated\n44d4c5b New README <span class=\"token function\">file</span>\nee42779 New demo <span class=\"token function\">file</span></code></pre></div>\n<p>The upper log shows a log history where the master branch (d9ad32e) and the\nlocal HEAD (259aff2) points to different commits. Except the first commit\n(2dc6065) there are no meaningful descriptions between them. Since each commit\nrefers to the same feature, a suitable solution to arrange the log is to use\n<code class=\"language-text\">rebase</code> to join them into one commit. </p>\n<p><code class=\"language-text\">rebase</code> is not only an alternative to the merge command. Actually, the command\nis meant to rewrite the project history. With that notion in mind, <code class=\"language-text\">rebase</code> is\nable to be used in the same branch. Instead of specifying a branch name, a\nprevious commit is passed in. Actually a branch name is not more that a\nmeaningful name pointing to a commit.</p>\n<p>There is more regarding the rebase. It can be executed automatically by default\nor interactively by passing the <code class=\"language-text\">-i</code> option. The Interactive mode gives the\npossibility to rearrange the log by modifying each commit with a specific command.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">g rebase -i d9ad32e</code></pre></div>\n<p>After running the previous command, the default editor pops out opening the\nnext file. In my case, vim is the default editor but you can set out yours\nby using the git config <a href=\"https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration#_code_core_editor_code\">core.editor</a> option.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">reword 2dc6065 new A <span class=\"token function\">file</span>\nfixup 71a621b A <span class=\"token function\">file</span> updated\nfixup 7a48555 wip: body content\nfixup 259aff2 body edit</code></pre></div>\n<p><code class=\"language-text\">fixup</code> or <code class=\"language-text\">f</code> for short, merges in bulk the marked commits with the previously\npicked one. In difference with <code class=\"language-text\">squash</code>, <code class=\"language-text\">fixup</code> don’t reuse the provided message.</p>\n<p><code class=\"language-text\">reword</code> allows to rewrite the commit message. <code class=\"language-text\">rebase</code> executes the provided\nactions after saving the file and closing the editor. When the task has been\ncompleted, the editor jumps again, allowing us to introduce the new commit description. </p>\n<p>Once the rebase has completed, the next log looks like below.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">2569f57 <span class=\"token punctuation\">(</span>HEAD -<span class=\"token operator\">></span> A<span class=\"token punctuation\">)</span> feature A\nd9ad32e <span class=\"token punctuation\">(</span>master<span class=\"token punctuation\">)</span> A new commit is introduced <span class=\"token keyword\">while</span> previous changes are <span class=\"token keyword\">in</span> stash\n13b16a5 Revert <span class=\"token string\">\"README updated\"</span>\n76a1097 Demo <span class=\"token function\">file</span> updated\na31e004 README updated\n44d4c5b New README <span class=\"token function\">file</span>\nee42779 New demo <span class=\"token function\">file</span></code></pre></div>\n<h2> Lots of related commits</h2>\n<p>Sometimes it happens to have a sudden idea while working on in a total different\nsubject. You stop working immediately what you’re at and start on that new idea.\nDamn serendipity!</p>\n<p>The next steps from a git perspective are (1) saving things up and (2) create a\nnew branch. Now, we are able to work in whatever is that brilliant idea. The\ngit loop starts: Work. Test things up. Save progress. And back to the beginning\nof the loop until the job is done.</p>\n<p>Finally we go back to the unfinished branch and start working again in the same loop.</p>\n<p>Lots of commits are created during this process. All of them refers to the same\ntopic. So, why keeping all these commits when actually only one commit per branch\nwill do? Is it not easier to search in the log for a commit with a one nice and\nconcise message than looking for a bunch of different commits? Are they in the\nsame slot? Do they got interlaced among unrelated commits?</p>\n<p>All right, we can pick and merge commits by doing a rebase, but why bother when\nwe already know everything relates to the same piece? Why not “squash” all of\nthem in the same first commit? Sure we can.</p>\n<p>Let’s tackle the <em>autosquash</em> feature.</p>\n<h3>Autosquash (or how to keep a clean log)</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">1a9bfea <span class=\"token punctuation\">(</span>HEAD -<span class=\"token operator\">></span> A<span class=\"token punctuation\">)</span> New A <span class=\"token function\">file</span>\nd9ad32e <span class=\"token punctuation\">(</span>master<span class=\"token punctuation\">)</span> A new commit is introduced <span class=\"token keyword\">while</span> previous changes are <span class=\"token keyword\">in</span> stash\n13b16a5 Revert <span class=\"token string\">\"README updated\"</span>\n76a1097 Demo <span class=\"token function\">file</span> updated\na31e004 README updated\n44d4c5b New README <span class=\"token function\">file</span>\nee42779 New demo <span class=\"token function\">file</span></code></pre></div>\n<p>After the first commit (1a9bfea), we see that we’re going to work over the same\nfile, so the next ones can be coerced up to be part of the first commit in the\ncurrent branch by using the option <code class=\"language-text\">--fixup</code>. </p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> commit —fixup<span class=\"token operator\">=</span>1a9bfea</code></pre></div>\n<p>As you recall fixup is one of the actions present in the rebase command.\nSimilarly, this fixup option allows merging the current commit into the\nprovided one. But first let’s see the resulting log.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">4cca556 <span class=\"token punctuation\">(</span>HEAD -<span class=\"token operator\">></span> A<span class=\"token punctuation\">)</span> fixup<span class=\"token operator\">!</span> New A <span class=\"token function\">file</span>\n1a9bfea New A <span class=\"token function\">file</span>\nd9ad32e <span class=\"token punctuation\">(</span>master<span class=\"token punctuation\">)</span> A new commit is introduced <span class=\"token keyword\">while</span> previous changes are <span class=\"token keyword\">in</span> stash\n13b16a5 Revert <span class=\"token string\">\"README updated\"</span>\n76a1097 Demo <span class=\"token function\">file</span> updated\na31e004 README updated\n44d4c5b New README <span class=\"token function\">file</span>\nee42779 New demo <span class=\"token function\">file</span></code></pre></div>\n<p>Have you noticed the “fixup!” prefix in the last commit message? Also the\nmessage is the same of the previous commit. Wait! wasn’t supposed to be merged\ninto the provided commit? Yes, it is. But don’t worry, it’s imperative to keep\nthe changes in the log, otherwise they could get lost. Later on will see how\nthey are merged.</p>\n<p>There is another way to fixup commits. Instead providing a specific commit hash,\na commit message can be look through by a matching text.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> commit —fixup<span class=\"token operator\">=</span>:/A\\ <span class=\"token function\">file</span></code></pre></div>","frontmatter":{"title":"Beyond Merge","date":"May 01, 2019","translations":null},"fields":{"readingTime":{"text":"9 min read","minutes":8.44}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/beyond-merge/","language":"en","previous":{"fields":{"slug":"/hi-folks/"},"frontmatter":{"title":"New Beginnings"}},"next":null}}